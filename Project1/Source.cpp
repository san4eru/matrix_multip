#include <fstream>
#include <iostream>

using namespace std;

/////////////// узнаем размер матрицы ///////////////
int fill_size(int &n, int &m) // принимает (адрес на число строк, адрес на число столбцов)
{
	ifstream in("input.txt"); // открываем файл на чтение
	if (in.is_open()) // если файл открылся
	{
		in >> n >> m; // считываем размер n и m
		in.close(); // закрываем файл
	}
	else // если файл НЕ открылся
	{
		return -1; // возращаем -1
	}
	return 0; // возращаем 0 если все хорошо
}

/////////////// считываем матрицу ///////////////
int fill_array(double **x, int n, int m) // принимает (указатель на матрицу, число строк, число столбцов)
{
	ifstream in("input.txt"); // открываем файл на чтение
	if (in.is_open()) // если файл открылся
	{
		in >> n >> m; // считываем размер n и m
		for (int i = 0; i < n; i++) // цикл по строчкам
			for (int j = 0; j < m; j++) // цикл по столбцам
				in >> x[i][j]; // считываем элемент марицы

		in.close(); // закрываем файл
	}
	else // если файл НЕ открылся
	{
		return -1; // возращаем -1
	}
	return 0; // возращаем 0 если все хорошо
}

/////////////// запись ответа в файл размер, матрица, произведение (вектор с) ///////////////
int WriteFile(double **x, int n, int m, double* vector) // принимает (указатель на матрицу, число строк, число столбцов, указатель на массив (вектор))
{
	ofstream in("output.txt"); // открываем файл на запись, если файоа нет, то создается
	if (in.is_open()) // если файл открылся
	{
		in << n << " " << m << endl; // записываем размер матрицв n m
		for (int i = 0; i < n; i++) // цикл по строчкам
		{
			for (int j = 0; j < m; j++) // цикл по столбцам
				in << x[i][j] << " "; // выводим элемент марицы через пробел
			in << endl; // переход на новую строчку 
		}
		in << endl; // пуская строчка

		for (int i = 0; i < n; i++) // цикл по строчкам
			in << vector[i + m] << endl; // выводим вектор с, каждый с новой строчки. i+m т.к. в начале от [0] до [m-1] лежит вектор b (транспонированная последняя строчка матрицы)

		in.close(); // закрываем файл
	}
	else // если файл НЕ открылся
	{
		return -1;  // возращаем -1
	}
	return 0; // возращаем 0 если все хорошо
}

/////////////// работа с матрицей ///////////////
void foo(double** x, int n, int m) // принимает (указатель на матрицу, число строк, число столбцов)
{
	double summ = 0; // сумма
	double temp; // переменная для того чтобы поменять местами
	for (int k = 0; k < m; k++) // цикл по столбцам
	{
		for (int j = 1; j < m; ++j) // цикл по столбцам
		{
			summ = 0; // обнуление суммы
			for (int i = 0; i < n; ++i) // цикл по строчкам
			{
				summ = summ + x[i][j - 1] - x[i][j]; // складываем в сумму предыдущее значение суммы и разность двух элементов соседних столбцов
			}
			if (summ > 0) { // если сумма > 0, меняем весь столбец
				for (int k = 0; k < n; k++) // цикл по строчкам
				{
					temp = x[k][j - 1];
					x[k][j - 1] = x[k][j];
					x[k][j] = temp;
				}
			}
		}
	}
}

/////////////// заполняем вектор b ///////////////
void fill_vector(double** x, int n, int m, double* vector) // принимает (указатель на матрицу, число строк, число столбцов, указатель на массив (вектор))
{
	for (int i = 0; i < m; i++) // цикл по столбцам
	{
		vector[i] = x[n - 1][i]; // кладем в вектор последную строчку; (n-1) - последняя строчка
	}
}

/////////////// умножение матриц ///////////////
void mult(double** x, double* vector, int n, int m) // принимает (указатель на матрицу, указатель на массив (вектор), число строк, число столбцов)
{
	int temp; // временная переменная (будеи хранить сумму произведение)
	for (int i = 0; i < n; i++) // цикл по строчкам
	{
		temp = 0; // временная переменная
		for (int j = 0; j < m; j++) // цикл по строчкам
		{
			temp += x[i][j] * vector[j]; // temp = temp + x[i][j] * vector[j]; суммируем прошлое значение и произведение эдементов матрицы
		}
		vector[i + m] = temp; // записываем вектор с. i+m т.к. в начале оот [0] до [m-1] лежитвектор b (транспонированная последняя строчка матрицы)
	}
}

int main()
{
	int n; // число строк
	int m; // число столбцов
	int flag = -1; // переменная для проверка 

	/////////////// узнаем размер матрицы ///////////////
	flag = fill_size(n, m); // вызов функции вернет либо -1, либо 0
	if (flag == -1) return -1; // если функция вернула -1 то завепшаем программу с -1

	/////////////// объявляем двумерный динамический массив для матрицы ///////////////
	double **x; // объявляем указатели на двумерный массив
	x = new double*[n]; // объявляем динамический массив (строчки)
	for (int i = 0; i < n; i++)  // цикл по строчкам
		x[i] = new double[m]; // объявляем динамические массивы (столбцы)

	/////////////// объявляем одномерный динамический массив для векторос ///////////////
	double *vector = new double[2 * m]; // 2*m т.к. в начале от [0] до [m-1] лежит вектор b (транспонированная последняя строчка матрицы), а от [m] до [2*m-1] лежит вектор c

	/////////////// заполнение матрицы из файла ///////////////
	flag = fill_array(x, n, m); // вызов функции вернет либо -1, либо 0
	if (flag == -1) return -1; // если функция вернула -1 то завепшаем программу с -1

	foo(x, n, m); // функция делает матрицу по вощрастанию

	fill_vector(x, n, m, vector); // функция заполняет вектор b

	mult(x, vector, n, m); // функция умножает вектор b и матрицу

	/////////////// запись ответа в файл ///////////////
	flag = WriteFile(x, n, m, vector); // вызов функции вернет либо -1, либо 0
	if (flag == -1) return -1; // если функция вернула -1 то завепшаем программу с -1

	/////////////// очистка памяти ///////////////
	for (int i = 0; i < n; i++) // цикл по строчкам
		delete[] x[i]; // очистка каждой строки матрицы
	delete[] x;  // очистка всех столбцов матрицы

	delete[] vector; // очистка массива с векторами

	return 0; // если все норм вернет 0
}